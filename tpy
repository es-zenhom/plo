#!/usr/bin/env python

import os
import sys
import argparse
import glob
import code
import traceback

import ROOT as r

from prompt_toolkit import prompt
from prompt_toolkit.history import FileHistory
from prompt_toolkit.auto_suggest import AutoSuggestFromHistory

from prompt_toolkit.contrib.completers import WordCompleter

from prompt_toolkit.key_binding.defaults import load_key_bindings_for_prompt
from prompt_toolkit.keys import Keys
from prompt_toolkit.styles import style_from_dict
from prompt_toolkit.token import Token

from pygments import lexers
from pygments.lexers.python import PythonLexer

def get_treename_from_file(tfile):
    """
    Given a tfile, this returns the name of the (only) ttree in the file, or
    "Events" in the case of MINIAOD
    """
    f1 = r.TFile(tfile)
    keys = f1.GetListOfKeys()
    treenames = [key.GetName() for key in keys if key.ReadObj().InheritsFrom(r.TTree.Class())]
    if len(treenames) > 1 and "Events" in treenames: treename = "Events"
    else: treename = treenames[0]
    return treename

def get_branch_info(ch):
    branches = list(ch.GetListOfBranches())
    tree = ch.GetTree()
    aliases = list(tree.GetListOfAliases())
    d_bname_to_info = {}
    if len(aliases):
        for a in aliases:
            aname = a.GetName()
            branch = tree.GetBranch(tree.GetAlias(aname))
            branchname = branch.GetName()
            cname = branch.GetClassName()
            btitle = branch.GetTitle()
            d_bname_to_info[branchname] = {"alias":aname.replace(".",""), "class": cname, "title": btitle, "branch":branch}
    else:
        for branch in branches:
            branchname = branch.GetName()
            cname = branch.GetClassName()
            btitle = branch.GetTitle()
            d_bname_to_info[branchname] = {"alias":branchname, "class": cname, "title": btitle, "branch":branch}
    for bn in d_bname_to_info:
        typ = ""
        d_bname_to_info[bn]["type"] = typ
        cname = d_bname_to_info[bn]["class"]

        if bn in ["EventSelections", "BranchListIndexes", "EventAuxiliary", "EventProductProvenance"]: continue

        if "edm::TriggerResults" in cname:
            continue

        # sometimes root is stupid and gives no class name, so must infer it from btitle (stuff like "btag_up/F")
        if not cname:
            if btitle.endswith("/i"): cname = "unsigned int"
            elif btitle.endswith("/l"): cname = "unsigned long long"
            elif btitle.endswith("/F"): cname = "float"
            elif btitle.endswith("/I"): cname = "int"
            elif btitle.endswith("/O"): cname = "bool"
            elif btitle.endswith("/D"): cname = "double"

            typ = cname[:].strip()

        else:
            if "edm::Wrapper" in cname:
                typ = cname.replace("edm::Wrapper<","")[:-1].strip()

        d_bname_to_info[bn]["type"] = typ

    return d_bname_to_info

def cat():
    if(r.gPad):
        c1 = r.gPad
        c1.SaveAs("temp.pdf")
        os.system("ic temp.pdf")

if __name__ == "__main__":

    parser = argparse.ArgumentParser()

    parser.add_argument("fpatt", help="input file(s), quoted if there are wildcards")
    parser.add_argument("-t", "--tree", help="tree name", default=None)
    args = parser.parse_args()

    tree_name = args.tree
    fpatt = args.fpatt
    if os.path.isdir(fpatt): fpatt += "/*.root"
    if not tree_name:
        if fpatt.startswith("/store/"):
            tree_name = "Events"
        else:
            tree_name = get_treename_from_file(glob.glob(fpatt)[0])
            print ">>> Found tree {}".format(tree_name)

    if fpatt.startswith("/store/"):
        fpatt = "root://cmsxrootd.fnal.gov//{}".format(fpatt)

    ch = r.TChain(tree_name)
    if ".root" in fpatt:
        ch.Add(fpatt)
    else:
        ch.Add("{}/*.root".format(fpatt))

    # make alias
    short_tree_name = tree_name.rsplit("/",1)[-1]
    exec("{} = ch".format(short_tree_name))

    print "Attached tree {}".format(short_tree_name)

    binfo = get_branch_info(ch)
    meta_dict = {bi["alias"]:bi["type"] for bi in binfo.values()}
    aliases = [bi["alias"] for bi in binfo.values()]


    ### Prompt stuff now

    mode = "python"
    registry = load_key_bindings_for_prompt()

    MyCompleter = WordCompleter(aliases,
            # ignore_case=True,
            # match_middle=True,
            meta_dict=meta_dict,
            )

    # Add a bottom toolbar to display the status.
    style = style_from_dict({
        Token.Toolbar: 'reverse',
        })

    def get_bottom_toolbar_tokens(cli):
        global mode
        text = 'python' if mode == "python" else 'root'
        return [
                (Token.Toolbar, ' [,, to switch] %s mode ' % text.upper())
                ]



    @registry.add_binding(u',', u',')
    def _(event):
        def switch_mode():
            global mode
            if mode == "root": mode = "python"
            else: mode = "root"
        event.cli.run_in_terminal(switch_mode)

    command_number = 0
    while 1:
        try:

            if mode == "python": ps1 = u">>> "
            else: ps1 = u"root [{}] ".format(command_number)
            
            inp = prompt(ps1,
                    history=FileHistory("history.txt"),
                    auto_suggest=AutoSuggestFromHistory(),
                    completer=MyCompleter,
                    lexer=PythonLexer,
                    key_bindings_registry=registry,
                    get_bottom_toolbar_tokens=get_bottom_toolbar_tokens,
                    style=style,
           )

            to_exec = inp[:]
            do_cat = False

            if "Draw(" in inp:
                do_cat = True
                if inp.count(":") > 1 and "col" not in inp:
                    do_cat = True

            if mode == "python":
                exec code.compile_command(to_exec)
            else:
                r.gInterpreter.ProcessLine(to_exec)
                if to_exec.strip() == ".q":
                    break

            if do_cat:
                cat()

        except KeyboardInterrupt as e:
            print "K bye"
            break

        except EOFError as e:
            print "K bye"
            break

        except Exception as e:
            traceback.print_exc()

        command_number += 1
